
## **Directory Structure**
This project follows a modular structure inspired by the [RISC Zero Rust Starter Template](https://github.com/risc0/risc0), but separates each logical component into its own crate under `src/`. Each subdirectory (e.g. `host`, `blockchain`, `fleetcore`, `methods/guest`) contains its own `Cargo.toml` and `src/`.

```tree
src/
├── blockchain/
├── fleetcore/
├── hello-world/
├── host/
├── methods/
│   ├── guest/
│   └── src/
```

In a RISC Zero project, the terms **methods** and **guest** are part of the framework's architecture that enables **zero-knowledge proofs of computation**.


## **How to Run the Project with Docker**
###  1. **Build and start all containers**

Run this once to build and launch the containers in the background:

```bash
docker-compose up --build -d
```
Note that:
- `--build` forces a rebuild of the Docker image using the Dockerfile (needed only if an alteration to said file was made).
- `-d` starts the containers in the background. If this flag is not used the terminal will display:
  ```bash
  [+] Running 2/2
  ✔ Container chain0   Created                    0.0s
  ✔ Container player0  Created                    0.0s
  Attaching to chain0, player0
  ```
This:
* Builds the Docker image from the `Dockerfile`
* Starts all services defined in `docker-compose.yml`  (`player0`, `chain0`)
* Mounts the source code directory to `/workspace`

### 2. **Enter a container terminal**
To enter the shell of a specific container:
```bash
# Enter the player container
docker exec -it player0 bash

# Enter the chain container
docker exec -it chain0 bash
```

### 3. **Run the program instances in each container**

Inside each container, use Cargo to run each program instance:
```bash
# For a player:
cd src/host/src
cargo run --bin host

# For the chain:
cd src/blockchain/src
cargo run --bin blockchain
```


### 4. **Stop the containers**

To stop the containers, either write:
```bash
docker-compose down
```
Or if the `-d` flag was not used, simply use `Ctrl + c` on the terminal `docker-compose up` was invoked

## **Some Notes related to the project**

### **1. Questions**
1. If the game action is invalid, should the player be removed from the game?
2. Should mistakes and invalid actions (such as firing when out of turn) be logged in the public transactions besides being reported to the player?

### **2. Report Note**
The Report proof is generated by the player who has been targeted by a shot. The purpose of the proof is to demonstrate, in zero knowledge, that:

1. The claimed shot result (`"Hit"` or `"Miss"`) is correct
2. The shot was applied honestly to the fleet
3. The updated board was correctly committed

#### **Inside the zkVM, the proof logic:**

1. Checks whether the position `pos` exists in `board`
2. Asserts that this matches the claimed result: `"Hit"` or `"Miss"`
3. If `"Hit"`, removes the position from the board
4. Computes the hash `next_board = Hash(nonce || updated_board)`
5. Computes the hash `board = Hash(nonce || original_board)`
6. Commits the public `ReportJournal`

If any of these assertions fail **The proof fails and the receipt is not sent.**

#### **Verifier POV**
Once the proof is submitted, the verifier performs the following checks:

1. `receipt.verify(REPORT_ID)` confirms the zkVM was executed honestly
2. The field `board` from the journal is compared against the player’s currently stored commitment (`player.current_state`).
3. After both of these checks, **the field `report` is trusted because it was derived in zero-knowledge inside the guest logic.**
4. The verifier updates the player’s state to `next_board`, which now reflects the shot having been applied.

Are the assumptions that **the proof fails and the receipt is not sent** and **the field `report` is trusted because it was derived in zero-knowledge inside the guest logic.** valid?
